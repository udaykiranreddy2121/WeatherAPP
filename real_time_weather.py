# -*- coding: utf-8 -*-
"""Real_Time_weather.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r3mu7CikI6-qBdOHdr2f6VYDMNr_f-e3
"""

pip install requests pandas SQLAlchemy

import requests
import time
import pandas as pd
from datetime import datetime
from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import matplotlib.pyplot as plt

# Configuration
API_KEY = '38f3c1e7bdeb6cf30e6d79ab15560087'  # Replace with your OpenWeatherMap API key
CITIES = ['Delhi', 'Mumbai', 'Chennai', 'Bangalore', 'Kolkata', 'Hyderabad']
BASE_URL = 'https://api.openweathermap.org/data/2.5/weather'
THRESHOLD_TEMP = 35.0  # Example: alert if temp exceeds 35°C
ALERT_CONSECUTIVE_COUNT = 2  # Number of consecutive breaches before alert

# Set up SQLite DB
Base = declarative_base()
engine = create_engine('sqlite:///weather_data.db')
Session = sessionmaker(bind=engine)
session = Session()

collected_data = {city: [] for city in CITIES}


# Define a model for daily summaries
class DailyWeatherSummary(Base):
    __tablename__ = 'weather_summaries'
    id = Column(Integer, primary_key=True)
    city = Column(String)
    date = Column(DateTime)
    avg_temp = Column(Float)
    max_temp = Column(Float)
    min_temp = Column(Float)
    dominant_weather = Column(String)

Base.metadata.create_all(engine)

# Alert state to track consecutive breaches
alert_state = {city: 0 for city in CITIES}

def fetch_weather_data(city):
    url = f"{BASE_URL}?q={city}&appid={API_KEY}&units=metric"  # Request in Celsius
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        return data
    else:
        print(f"Error fetching data for {city}: {response.status_code} - {response.text}")
        return None

def process_weather_data(data):
    main_weather = data['weather'][0]['main']
    temp = data['main']['temp'] - 273.15  # Convert from Kelvin to Celsius
    feels_like = data['main']['feels_like'] - 273.15
    dt = datetime.utcfromtimestamp(data['dt']).strftime('%Y-%m-%d %H:%M:%S')

    weather_summary = {
        'city': data['name'],
        'main_weather': main_weather,
        'temp': temp,
        'feels_like': feels_like,
        'timestamp': dt
    }
    print(weather_summary)

    # Check for alert condition
    check_alert(data['name'], temp)

    # Return the processed data
    return weather_summary

def check_alert(city, temp):
    global alert_state
    if temp > THRESHOLD_TEMP:
        alert_state[city] += 1
        if alert_state[city] >= ALERT_CONSECUTIVE_COUNT:
            print(f"ALERT: Temperature in {city} has exceeded {THRESHOLD_TEMP}°C for {ALERT_CONSECUTIVE_COUNT} consecutive updates!")
            alert_state[city] = 0  # Reset after triggering the alert
    else:
        alert_state[city] = 0  # Reset if temp goes below the threshold

def store_weather_summary(city, date, avg_temp, max_temp, min_temp, dominant_weather):
    summary = DailyWeatherSummary(
        city=city,
        date=date,
        avg_temp=avg_temp,
        max_temp=max_temp,
        min_temp=min_temp,
        dominant_weather=dominant_weather
    )
    session.add(summary)
    session.commit()

def calculate_daily_aggregates(data_list):
    df = pd.DataFrame(data_list)
    avg_temp = df['temp'].mean()
    max_temp = df['temp'].max()
    min_temp = df['temp'].min()
    dominant_weather = df['main_weather'].mode()[0]  # Most frequent weather condition

    # Store the summary in the database
    store_weather_summary(df['city'][0], datetime.now(), avg_temp, max_temp, min_temp, dominant_weather)

    print(f"Daily Summary: {df['city'][0]} -> Avg: {avg_temp:.2f}°C, Max: {max_temp:.2f}°C, Min: {min_temp:.2f}°C, Dominant Weather: {dominant_weather}")

def visualize_weather_data():
    df = pd.read_sql('SELECT * FROM weather_summaries', engine)
    df['date'] = pd.to_datetime(df['date'])

    # Plot temperature trends
    plt.figure(figsize=(10, 5))
    for city in df['city'].unique():
        city_data = df[df['city'] == city]
        plt.plot(city_data['date'], city_data['avg_temp'], label=city)
    plt.title('Average Temperature Over Time')
    plt.xlabel('Date')
    plt.ylabel('Temperature (°C)')
    plt.legend()
    plt.show()

def main():
    collected_data = {city: [] for city in CITIES}

    while True:
        for city in CITIES:
            data = fetch_weather_data(city)
            if data:
                processed_data = process_weather_data(data)
                collected_data[city].append(processed_data)

            # Calculate daily summary once enough data is collected
            if len(collected_data[city]) >= 288:  # Assuming 5-min intervals in 24 hours (~288 intervals)
                calculate_daily_aggregates(collected_data[city])
                collected_data[city] = []  # Reset for the next day

        # Call visualization after processing the daily summary
        visualize_weather_data()

        time.sleep(60)  # Sleep for 1 minute before fetching new data (set to 5 minutes in production)

if __name__ == "__main__":
    main()

import requests
import time
import pandas as pd
from datetime import datetime
from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import matplotlib.pyplot as plt

# Configuration
API_KEY = '38f3c1e7bdeb6cf30e6d79ab15560087'  # Replace with your OpenWeatherMap API key
CITIES = ['Delhi', 'Mumbai', 'Chennai', 'Bangalore', 'Kolkata', 'Hyderabad']
BASE_URL = 'https://api.openweathermap.org/data/2.5/weather'
THRESHOLD_TEMP = 35.0  # Example: alert if temp exceeds 35°C
ALERT_CONSECUTIVE_COUNT = 2  # Number of consecutive breaches before alert

# Set up SQLite DB
Base = declarative_base()
engine = create_engine('sqlite:///weather_data.db')
Session = sessionmaker(bind=engine)
session = Session()

# Define a model for daily summaries
class DailyWeatherSummary(Base):
    __tablename__ = 'weather_summaries'
    id = Column(Integer, primary_key=True)
    city = Column(String)
    date = Column(DateTime)
    avg_temp = Column(Float)
    max_temp = Column(Float)
    min_temp = Column(Float)
    dominant_weather = Column(String)

# Create the database table
Base.metadata.create_all(engine)

# Alert state to track consecutive breaches
alert_state = {city: 0 for city in CITIES}

def fetch_weather_data(city):
    url = f"{BASE_URL}?q={city}&appid={API_KEY}&units=metric"  # Request in Celsius
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        return data
    else:
        print(f"Error fetching data for {city}: {response.status_code} - {response.text}")
        return None

def process_weather_data(data):
    main_weather = data['weather'][0]['main']
    temp = data['main']['temp']  # Already in Celsius
    feels_like = data['main']['feels_like']
    dt = datetime.utcfromtimestamp(data['dt']).strftime('%Y-%m-%d %H:%M:%S')

    weather_summary = {
        'city': data['name'],
        'main_weather': main_weather,
        'temp': temp,
        'feels_like': feels_like,
        'timestamp': dt
    }
    print(weather_summary)  # Debug output to track the weather data

    # Check for alert condition
    check_alert(data['name'], temp)

    # Return the processed data
    return weather_summary

def check_alert(city, temp):
    global alert_state
    if temp > THRESHOLD_TEMP:
        alert_state[city] += 1
        if alert_state[city] >= ALERT_CONSECUTIVE_COUNT:
            print(f"ALERT: Temperature in {city} has exceeded {THRESHOLD_TEMP}°C for {ALERT_CONSECUTIVE_COUNT} consecutive updates!")
            alert_state[city] = 0  # Reset after triggering the alert
    else:
        alert_state[city] = 0  # Reset if temp goes below the threshold

def store_weather_summary(city, date, avg_temp, max_temp, min_temp, dominant_weather):
    summary = DailyWeatherSummary(
        city=city,
        date=date,
        avg_temp=avg_temp,
        max_temp=max_temp,
        min_temp=min_temp,
        dominant_weather=dominant_weather
    )
    session.add(summary)
    session.commit()

def calculate_daily_aggregates(data_list):
    # Ensure we received data to calculate
    if not data_list:
        print("No data available for daily aggregates.")
        return

    df = pd.DataFrame(data_list)
    avg_temp = df['temp'].mean()
    max_temp = df['temp'].max()
    min_temp = df['temp'].min()
    dominant_weather = df['main_weather'].mode()[0]  # Most frequent weather condition

    # Store the summary in the database
    store_weather_summary(df['city'][0], datetime.now(), avg_temp, max_temp, min_temp, dominant_weather)

    print(f"Daily Summary: {df['city'][0]} -> Avg: {avg_temp:.2f}°C, Max: {max_temp:.2f}°C, Min: {min_temp:.2f}°C, Dominant Weather: {dominant_weather}")

def visualize_weather_data():
    df = pd.read_sql('SELECT * FROM weather_summaries', engine)
    df['date'] = pd.to_datetime(df['date'])

    # Create a new column for just the time
    df['time'] = df['date'].dt.time

    # Plot temperature trends
    plt.figure(figsize=(10, 5))
    for city in df['city'].unique():
        city_data = df[df['city'] == city]
        plt.plot(city_data['time'], city_data['avg_temp'], marker='o', label=city)  # Added marker for better visibility

    plt.title('Average Temperature Over Time')
    plt.xlabel('Time of Day')  # Changed label to Time of Day
    plt.ylabel('Temperature (°C)')
    plt.xticks(rotation=45)  # Rotate x-axis labels for better readability
    plt.grid()
    plt.legend()
    plt.tight_layout()  # Adjust layout to prevent clipping
    plt.show()


def main():
    collected_data = {city: [] for city in CITIES}

    while True:
        for city in CITIES:
            data = fetch_weather_data(city)
            if data:
                processed_data = process_weather_data(data)
                collected_data[city].append(processed_data)

            # Calculate daily summary once enough data is collected
            if len(collected_data[city]) >= 288:  # Assuming 5-min intervals in 24 hours (~288 intervals)
                print(f"Calculating daily aggregates for {city}...")
                calculate_daily_aggregates(collected_data[city])
                collected_data[city] = []  # Reset for the next day

        # Call visualization after processing the daily summary
        visualize_weather_data()

        time.sleep(301)  # Sleep for 1 minute before fetching new data (set to 5 minutes in production)

if __name__ == "__main__":
    main()

print(f"Total entries in database: {session.query(DailyWeatherSummary).count()}")